// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.3
// source: authService.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Account, AccountInfo, Email, Password } from "./account.js";
import { Empty } from "./google/protobuf/empty.js";

export const protobufPackage = "pb";

export interface LoginData {
    email: Email | undefined;
    password: Password | undefined;
}

export interface Token {
    token: string;
}

export interface RefreshToken {
    refreshToken: Token | undefined;
}

export interface AccessToken {
    accessToken: Token | undefined;
}

export interface PairTokens {
    accessToken: AccessToken | undefined;
    refreshToken: RefreshToken | undefined;
}

export interface NewPassword {
    oldPassword: Password | undefined;
    password: Password | undefined;
}

export interface NewEmail {
    email: Email | undefined;
}

export interface VerifyTokenResponse {
    status: boolean;
    accountId: string;
}

export interface OTPRequest {
    email: Email | undefined;
    code: string;
}

export interface OTPResponse {
    status: boolean;
}

export interface RestorePasswordRequest {
    email: Email | undefined;
    newPassword: Password | undefined;
}

export interface SendOTPRequest {
    email: Email | undefined;
}

export interface TokensWithUserInfo {
    accessToken: AccessToken | undefined;
    refreshToken: RefreshToken | undefined;
    account: AccountInfo | undefined;
}

function createBaseLoginData(): LoginData {
    return { email: undefined, password: undefined };
}

export const LoginData = {
    encode(
        message: LoginData,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.email !== undefined) {
            Email.encode(message.email, writer.uint32(10).fork()).ldelim();
        }
        if (message.password !== undefined) {
            Password.encode(
                message.password,
                writer.uint32(18).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): LoginData {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoginData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.email = Email.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.password = Password.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): LoginData {
        return {
            email: isSet(object.email)
                ? Email.fromJSON(object.email)
                : undefined,
            password: isSet(object.password)
                ? Password.fromJSON(object.password)
                : undefined,
        };
    },

    toJSON(message: LoginData): unknown {
        const obj: any = {};
        if (message.email !== undefined) {
            obj.email = Email.toJSON(message.email);
        }
        if (message.password !== undefined) {
            obj.password = Password.toJSON(message.password);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<LoginData>, I>>(base?: I): LoginData {
        return LoginData.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<LoginData>, I>>(
        object: I
    ): LoginData {
        const message = createBaseLoginData();
        message.email =
            object.email !== undefined && object.email !== null
                ? Email.fromPartial(object.email)
                : undefined;
        message.password =
            object.password !== undefined && object.password !== null
                ? Password.fromPartial(object.password)
                : undefined;
        return message;
    },
};

function createBaseToken(): Token {
    return { token: "" };
}

export const Token = {
    encode(
        message: Token,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.token !== "") {
            writer.uint32(10).string(message.token);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): Token {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.token = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): Token {
        return {
            token: isSet(object.token) ? globalThis.String(object.token) : "",
        };
    },

    toJSON(message: Token): unknown {
        const obj: any = {};
        if (message.token !== "") {
            obj.token = message.token;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
        return Token.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
        const message = createBaseToken();
        message.token = object.token ?? "";
        return message;
    },
};

function createBaseRefreshToken(): RefreshToken {
    return { refreshToken: undefined };
}

export const RefreshToken = {
    encode(
        message: RefreshToken,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.refreshToken !== undefined) {
            Token.encode(
                message.refreshToken,
                writer.uint32(10).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): RefreshToken {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.refreshToken = Token.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): RefreshToken {
        return {
            refreshToken: isSet(object.refreshToken)
                ? Token.fromJSON(object.refreshToken)
                : undefined,
        };
    },

    toJSON(message: RefreshToken): unknown {
        const obj: any = {};
        if (message.refreshToken !== undefined) {
            obj.refreshToken = Token.toJSON(message.refreshToken);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<RefreshToken>, I>>(
        base?: I
    ): RefreshToken {
        return RefreshToken.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RefreshToken>, I>>(
        object: I
    ): RefreshToken {
        const message = createBaseRefreshToken();
        message.refreshToken =
            object.refreshToken !== undefined && object.refreshToken !== null
                ? Token.fromPartial(object.refreshToken)
                : undefined;
        return message;
    },
};

function createBaseAccessToken(): AccessToken {
    return { accessToken: undefined };
}

export const AccessToken = {
    encode(
        message: AccessToken,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.accessToken !== undefined) {
            Token.encode(
                message.accessToken,
                writer.uint32(10).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): AccessToken {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccessToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.accessToken = Token.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): AccessToken {
        return {
            accessToken: isSet(object.accessToken)
                ? Token.fromJSON(object.accessToken)
                : undefined,
        };
    },

    toJSON(message: AccessToken): unknown {
        const obj: any = {};
        if (message.accessToken !== undefined) {
            obj.accessToken = Token.toJSON(message.accessToken);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<AccessToken>, I>>(
        base?: I
    ): AccessToken {
        return AccessToken.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<AccessToken>, I>>(
        object: I
    ): AccessToken {
        const message = createBaseAccessToken();
        message.accessToken =
            object.accessToken !== undefined && object.accessToken !== null
                ? Token.fromPartial(object.accessToken)
                : undefined;
        return message;
    },
};

function createBasePairTokens(): PairTokens {
    return { accessToken: undefined, refreshToken: undefined };
}

export const PairTokens = {
    encode(
        message: PairTokens,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.accessToken !== undefined) {
            AccessToken.encode(
                message.accessToken,
                writer.uint32(10).fork()
            ).ldelim();
        }
        if (message.refreshToken !== undefined) {
            RefreshToken.encode(
                message.refreshToken,
                writer.uint32(18).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): PairTokens {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePairTokens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.accessToken = AccessToken.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.refreshToken = RefreshToken.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): PairTokens {
        return {
            accessToken: isSet(object.accessToken)
                ? AccessToken.fromJSON(object.accessToken)
                : undefined,
            refreshToken: isSet(object.refreshToken)
                ? RefreshToken.fromJSON(object.refreshToken)
                : undefined,
        };
    },

    toJSON(message: PairTokens): unknown {
        const obj: any = {};
        if (message.accessToken !== undefined) {
            obj.accessToken = AccessToken.toJSON(message.accessToken);
        }
        if (message.refreshToken !== undefined) {
            obj.refreshToken = RefreshToken.toJSON(message.refreshToken);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<PairTokens>, I>>(base?: I): PairTokens {
        return PairTokens.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<PairTokens>, I>>(
        object: I
    ): PairTokens {
        const message = createBasePairTokens();
        message.accessToken =
            object.accessToken !== undefined && object.accessToken !== null
                ? AccessToken.fromPartial(object.accessToken)
                : undefined;
        message.refreshToken =
            object.refreshToken !== undefined && object.refreshToken !== null
                ? RefreshToken.fromPartial(object.refreshToken)
                : undefined;
        return message;
    },
};

function createBaseNewPassword(): NewPassword {
    return { oldPassword: undefined, password: undefined };
}

export const NewPassword = {
    encode(
        message: NewPassword,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.oldPassword !== undefined) {
            Password.encode(
                message.oldPassword,
                writer.uint32(10).fork()
            ).ldelim();
        }
        if (message.password !== undefined) {
            Password.encode(
                message.password,
                writer.uint32(18).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): NewPassword {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNewPassword();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.oldPassword = Password.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.password = Password.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): NewPassword {
        return {
            oldPassword: isSet(object.oldPassword)
                ? Password.fromJSON(object.oldPassword)
                : undefined,
            password: isSet(object.password)
                ? Password.fromJSON(object.password)
                : undefined,
        };
    },

    toJSON(message: NewPassword): unknown {
        const obj: any = {};
        if (message.oldPassword !== undefined) {
            obj.oldPassword = Password.toJSON(message.oldPassword);
        }
        if (message.password !== undefined) {
            obj.password = Password.toJSON(message.password);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<NewPassword>, I>>(
        base?: I
    ): NewPassword {
        return NewPassword.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<NewPassword>, I>>(
        object: I
    ): NewPassword {
        const message = createBaseNewPassword();
        message.oldPassword =
            object.oldPassword !== undefined && object.oldPassword !== null
                ? Password.fromPartial(object.oldPassword)
                : undefined;
        message.password =
            object.password !== undefined && object.password !== null
                ? Password.fromPartial(object.password)
                : undefined;
        return message;
    },
};

function createBaseNewEmail(): NewEmail {
    return { email: undefined };
}

export const NewEmail = {
    encode(
        message: NewEmail,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.email !== undefined) {
            Email.encode(message.email, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): NewEmail {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNewEmail();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.email = Email.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): NewEmail {
        return {
            email: isSet(object.email)
                ? Email.fromJSON(object.email)
                : undefined,
        };
    },

    toJSON(message: NewEmail): unknown {
        const obj: any = {};
        if (message.email !== undefined) {
            obj.email = Email.toJSON(message.email);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<NewEmail>, I>>(base?: I): NewEmail {
        return NewEmail.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<NewEmail>, I>>(
        object: I
    ): NewEmail {
        const message = createBaseNewEmail();
        message.email =
            object.email !== undefined && object.email !== null
                ? Email.fromPartial(object.email)
                : undefined;
        return message;
    },
};

function createBaseVerifyTokenResponse(): VerifyTokenResponse {
    return { status: false, accountId: "" };
}

export const VerifyTokenResponse = {
    encode(
        message: VerifyTokenResponse,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.status !== false) {
            writer.uint32(8).bool(message.status);
        }
        if (message.accountId !== "") {
            writer.uint32(18).string(message.accountId);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): VerifyTokenResponse {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifyTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }

                    message.status = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.accountId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): VerifyTokenResponse {
        return {
            status: isSet(object.status)
                ? globalThis.Boolean(object.status)
                : false,
            accountId: isSet(object.accountId)
                ? globalThis.String(object.accountId)
                : "",
        };
    },

    toJSON(message: VerifyTokenResponse): unknown {
        const obj: any = {};
        if (message.status !== false) {
            obj.status = message.status;
        }
        if (message.accountId !== "") {
            obj.accountId = message.accountId;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(
        base?: I
    ): VerifyTokenResponse {
        return VerifyTokenResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(
        object: I
    ): VerifyTokenResponse {
        const message = createBaseVerifyTokenResponse();
        message.status = object.status ?? false;
        message.accountId = object.accountId ?? "";
        return message;
    },
};

function createBaseOTPRequest(): OTPRequest {
    return { email: undefined, code: "" };
}

export const OTPRequest = {
    encode(
        message: OTPRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.email !== undefined) {
            Email.encode(message.email, writer.uint32(10).fork()).ldelim();
        }
        if (message.code !== "") {
            writer.uint32(18).string(message.code);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): OTPRequest {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOTPRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.email = Email.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.code = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): OTPRequest {
        return {
            email: isSet(object.email)
                ? Email.fromJSON(object.email)
                : undefined,
            code: isSet(object.code) ? globalThis.String(object.code) : "",
        };
    },

    toJSON(message: OTPRequest): unknown {
        const obj: any = {};
        if (message.email !== undefined) {
            obj.email = Email.toJSON(message.email);
        }
        if (message.code !== "") {
            obj.code = message.code;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<OTPRequest>, I>>(base?: I): OTPRequest {
        return OTPRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OTPRequest>, I>>(
        object: I
    ): OTPRequest {
        const message = createBaseOTPRequest();
        message.email =
            object.email !== undefined && object.email !== null
                ? Email.fromPartial(object.email)
                : undefined;
        message.code = object.code ?? "";
        return message;
    },
};

function createBaseOTPResponse(): OTPResponse {
    return { status: false };
}

export const OTPResponse = {
    encode(
        message: OTPResponse,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.status !== false) {
            writer.uint32(8).bool(message.status);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): OTPResponse {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOTPResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }

                    message.status = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): OTPResponse {
        return {
            status: isSet(object.status)
                ? globalThis.Boolean(object.status)
                : false,
        };
    },

    toJSON(message: OTPResponse): unknown {
        const obj: any = {};
        if (message.status !== false) {
            obj.status = message.status;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<OTPResponse>, I>>(
        base?: I
    ): OTPResponse {
        return OTPResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OTPResponse>, I>>(
        object: I
    ): OTPResponse {
        const message = createBaseOTPResponse();
        message.status = object.status ?? false;
        return message;
    },
};

function createBaseRestorePasswordRequest(): RestorePasswordRequest {
    return { email: undefined, newPassword: undefined };
}

export const RestorePasswordRequest = {
    encode(
        message: RestorePasswordRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.email !== undefined) {
            Email.encode(message.email, writer.uint32(10).fork()).ldelim();
        }
        if (message.newPassword !== undefined) {
            Password.encode(
                message.newPassword,
                writer.uint32(18).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): RestorePasswordRequest {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRestorePasswordRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.email = Email.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.newPassword = Password.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): RestorePasswordRequest {
        return {
            email: isSet(object.email)
                ? Email.fromJSON(object.email)
                : undefined,
            newPassword: isSet(object.newPassword)
                ? Password.fromJSON(object.newPassword)
                : undefined,
        };
    },

    toJSON(message: RestorePasswordRequest): unknown {
        const obj: any = {};
        if (message.email !== undefined) {
            obj.email = Email.toJSON(message.email);
        }
        if (message.newPassword !== undefined) {
            obj.newPassword = Password.toJSON(message.newPassword);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<RestorePasswordRequest>, I>>(
        base?: I
    ): RestorePasswordRequest {
        return RestorePasswordRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RestorePasswordRequest>, I>>(
        object: I
    ): RestorePasswordRequest {
        const message = createBaseRestorePasswordRequest();
        message.email =
            object.email !== undefined && object.email !== null
                ? Email.fromPartial(object.email)
                : undefined;
        message.newPassword =
            object.newPassword !== undefined && object.newPassword !== null
                ? Password.fromPartial(object.newPassword)
                : undefined;
        return message;
    },
};

function createBaseSendOTPRequest(): SendOTPRequest {
    return { email: undefined };
}

export const SendOTPRequest = {
    encode(
        message: SendOTPRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.email !== undefined) {
            Email.encode(message.email, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): SendOTPRequest {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendOTPRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.email = Email.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): SendOTPRequest {
        return {
            email: isSet(object.email)
                ? Email.fromJSON(object.email)
                : undefined,
        };
    },

    toJSON(message: SendOTPRequest): unknown {
        const obj: any = {};
        if (message.email !== undefined) {
            obj.email = Email.toJSON(message.email);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<SendOTPRequest>, I>>(
        base?: I
    ): SendOTPRequest {
        return SendOTPRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SendOTPRequest>, I>>(
        object: I
    ): SendOTPRequest {
        const message = createBaseSendOTPRequest();
        message.email =
            object.email !== undefined && object.email !== null
                ? Email.fromPartial(object.email)
                : undefined;
        return message;
    },
};

function createBaseTokensWithUserInfo(): TokensWithUserInfo {
    return {
        accessToken: undefined,
        refreshToken: undefined,
        account: undefined,
    };
}

export const TokensWithUserInfo = {
    encode(
        message: TokensWithUserInfo,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.accessToken !== undefined) {
            AccessToken.encode(
                message.accessToken,
                writer.uint32(10).fork()
            ).ldelim();
        }
        if (message.refreshToken !== undefined) {
            RefreshToken.encode(
                message.refreshToken,
                writer.uint32(18).fork()
            ).ldelim();
        }
        if (message.account !== undefined) {
            AccountInfo.encode(
                message.account,
                writer.uint32(26).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): TokensWithUserInfo {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokensWithUserInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.accessToken = AccessToken.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.refreshToken = RefreshToken.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }

                    message.account = AccountInfo.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): TokensWithUserInfo {
        return {
            accessToken: isSet(object.accessToken)
                ? AccessToken.fromJSON(object.accessToken)
                : undefined,
            refreshToken: isSet(object.refreshToken)
                ? RefreshToken.fromJSON(object.refreshToken)
                : undefined,
            account: isSet(object.account)
                ? AccountInfo.fromJSON(object.account)
                : undefined,
        };
    },

    toJSON(message: TokensWithUserInfo): unknown {
        const obj: any = {};
        if (message.accessToken !== undefined) {
            obj.accessToken = AccessToken.toJSON(message.accessToken);
        }
        if (message.refreshToken !== undefined) {
            obj.refreshToken = RefreshToken.toJSON(message.refreshToken);
        }
        if (message.account !== undefined) {
            obj.account = AccountInfo.toJSON(message.account);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<TokensWithUserInfo>, I>>(
        base?: I
    ): TokensWithUserInfo {
        return TokensWithUserInfo.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TokensWithUserInfo>, I>>(
        object: I
    ): TokensWithUserInfo {
        const message = createBaseTokensWithUserInfo();
        message.accessToken =
            object.accessToken !== undefined && object.accessToken !== null
                ? AccessToken.fromPartial(object.accessToken)
                : undefined;
        message.refreshToken =
            object.refreshToken !== undefined && object.refreshToken !== null
                ? RefreshToken.fromPartial(object.refreshToken)
                : undefined;
        message.account =
            object.account !== undefined && object.account !== null
                ? AccountInfo.fromPartial(object.account)
                : undefined;
        return message;
    },
};

export interface SSOServerService {
    SignUp(request: Account): Promise<TokensWithUserInfo>;
    Login(request: LoginData): Promise<TokensWithUserInfo>;
    VerifyToken(request: Token): Promise<VerifyTokenResponse>;
    Logout(request: Empty): Promise<Empty>;
    RotateTokens(request: RefreshToken): Promise<PairTokens>;
    ChangePassword(request: NewPassword): Promise<PairTokens>;
    ChangeEmail(request: NewEmail): Promise<PairTokens>;
    SendOTP(request: SendOTPRequest): Promise<Empty>;
    CheckOTP(request: OTPRequest): Promise<OTPResponse>;
    RestorePassword(request: RestorePasswordRequest): Promise<PairTokens>;
    LogoutFromDevices(request: Empty): Promise<Empty>;
}

export const SSOServerServiceServiceName = "pb.SSOServerService";
export class SSOServerServiceClientImpl implements SSOServerService {
    private readonly rpc: Rpc;
    private readonly service: string;
    constructor(rpc: Rpc, opts?: { service?: string }) {
        this.service = opts?.service || SSOServerServiceServiceName;
        this.rpc = rpc;
        this.SignUp = this.SignUp.bind(this);
        this.Login = this.Login.bind(this);
        this.VerifyToken = this.VerifyToken.bind(this);
        this.Logout = this.Logout.bind(this);
        this.RotateTokens = this.RotateTokens.bind(this);
        this.ChangePassword = this.ChangePassword.bind(this);
        this.ChangeEmail = this.ChangeEmail.bind(this);
        this.SendOTP = this.SendOTP.bind(this);
        this.CheckOTP = this.CheckOTP.bind(this);
        this.RestorePassword = this.RestorePassword.bind(this);
        this.LogoutFromDevices = this.LogoutFromDevices.bind(this);
    }
    SignUp(request: Account): Promise<TokensWithUserInfo> {
        const data = Account.encode(request).finish();
        const promise = this.rpc.request(this.service, "SignUp", data);
        return promise.then((data) =>
            TokensWithUserInfo.decode(_m0.Reader.create(data))
        );
    }

    Login(request: LoginData): Promise<TokensWithUserInfo> {
        const data = LoginData.encode(request).finish();
        const promise = this.rpc.request(this.service, "Login", data);
        return promise.then((data) =>
            TokensWithUserInfo.decode(_m0.Reader.create(data))
        );
    }

    VerifyToken(request: Token): Promise<VerifyTokenResponse> {
        const data = Token.encode(request).finish();
        const promise = this.rpc.request(this.service, "VerifyToken", data);
        return promise.then((data) =>
            VerifyTokenResponse.decode(_m0.Reader.create(data))
        );
    }

    Logout(request: Empty): Promise<Empty> {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(this.service, "Logout", data);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }

    RotateTokens(request: RefreshToken): Promise<PairTokens> {
        const data = RefreshToken.encode(request).finish();
        const promise = this.rpc.request(this.service, "RotateTokens", data);
        return promise.then((data) =>
            PairTokens.decode(_m0.Reader.create(data))
        );
    }

    ChangePassword(request: NewPassword): Promise<PairTokens> {
        const data = NewPassword.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChangePassword", data);
        return promise.then((data) =>
            PairTokens.decode(_m0.Reader.create(data))
        );
    }

    ChangeEmail(request: NewEmail): Promise<PairTokens> {
        const data = NewEmail.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChangeEmail", data);
        return promise.then((data) =>
            PairTokens.decode(_m0.Reader.create(data))
        );
    }

    SendOTP(request: SendOTPRequest): Promise<Empty> {
        const data = SendOTPRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "SendOTP", data);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }

    CheckOTP(request: OTPRequest): Promise<OTPResponse> {
        const data = OTPRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "CheckOTP", data);
        return promise.then((data) =>
            OTPResponse.decode(_m0.Reader.create(data))
        );
    }

    RestorePassword(request: RestorePasswordRequest): Promise<PairTokens> {
        const data = RestorePasswordRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "RestorePassword", data);
        return promise.then((data) =>
            PairTokens.decode(_m0.Reader.create(data))
        );
    }

    LogoutFromDevices(request: Empty): Promise<Empty> {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(
            this.service,
            "LogoutFromDevices",
            data
        );
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }
}

interface Rpc {
    request(
        service: string,
        method: string,
        data: Uint8Array
    ): Promise<Uint8Array>;
}

type Builtin =
    | Date
    | Function
    | Uint8Array
    | string
    | number
    | boolean
    | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
          [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
      };

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}
