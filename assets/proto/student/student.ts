// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.28.2
// source: assets/proto/student/student.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "student";

/** Skill message definition */
export interface Skill {
  name: string;
  level: string;
}

/** Student message definition */
export interface Student {
  FirstName: string;
  MiddleName: string;
  LastName: string;
  BornDate: string;
  Education: string;
  Location: string;
  PhotoURL: string;
  Photo: Uint8Array;
  AccountID: string;
}

export interface StudentCreateRequest {
  student: Student | undefined;
}

export interface StudentCreateUpdateResponse {
  id: string;
  message: string;
  student: Student | undefined;
}

export interface StudentUpdateRequest {
  studentId: string;
  student: Student | undefined;
}

export interface GetStudentByIDRequest {
  studentId: string;
}

export interface GetStudentByIDResponse {
  student: Student | undefined;
}

export interface ListStudentsRequest {
}

export interface ListStudentsResponse {
  students: Student[];
}

/** Запрос для проверки существования токена */
export interface TokenExistsRequest {
  /** SubjectId из токена */
  subjectId: string;
}

/** Ответ на запрос проверки существования токена */
export interface TokenExistsResponse {
  /** Существует ли токен */
  exists: boolean;
}

export interface GetStudentByTokenRequest {
}

function createBaseSkill(): Skill {
  return { name: "", level: "" };
}

export const Skill: MessageFns<Skill> = {
  encode(message: Skill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.level !== "") {
      writer.uint32(18).string(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Skill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.level = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Skill {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
    };
  },

  toJSON(message: Skill): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Skill>, I>>(base?: I): Skill {
    return Skill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Skill>, I>>(object: I): Skill {
    const message = createBaseSkill();
    message.name = object.name ?? "";
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseStudent(): Student {
  return {
    FirstName: "",
    MiddleName: "",
    LastName: "",
    BornDate: "",
    Education: "",
    Location: "",
    PhotoURL: "",
    Photo: new Uint8Array(0),
    AccountID: "",
  };
}

export const Student: MessageFns<Student> = {
  encode(message: Student, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.FirstName !== "") {
      writer.uint32(18).string(message.FirstName);
    }
    if (message.MiddleName !== "") {
      writer.uint32(26).string(message.MiddleName);
    }
    if (message.LastName !== "") {
      writer.uint32(34).string(message.LastName);
    }
    if (message.BornDate !== "") {
      writer.uint32(42).string(message.BornDate);
    }
    if (message.Education !== "") {
      writer.uint32(50).string(message.Education);
    }
    if (message.Location !== "") {
      writer.uint32(58).string(message.Location);
    }
    if (message.PhotoURL !== "") {
      writer.uint32(66).string(message.PhotoURL);
    }
    if (message.Photo.length !== 0) {
      writer.uint32(74).bytes(message.Photo);
    }
    if (message.AccountID !== "") {
      writer.uint32(82).string(message.AccountID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Student {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.FirstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.MiddleName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.LastName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.BornDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.Education = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.Location = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.PhotoURL = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.Photo = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.AccountID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Student {
    return {
      FirstName: isSet(object.FirstName) ? globalThis.String(object.FirstName) : "",
      MiddleName: isSet(object.MiddleName) ? globalThis.String(object.MiddleName) : "",
      LastName: isSet(object.LastName) ? globalThis.String(object.LastName) : "",
      BornDate: isSet(object.BornDate) ? globalThis.String(object.BornDate) : "",
      Education: isSet(object.Education) ? globalThis.String(object.Education) : "",
      Location: isSet(object.Location) ? globalThis.String(object.Location) : "",
      PhotoURL: isSet(object.PhotoURL) ? globalThis.String(object.PhotoURL) : "",
      Photo: isSet(object.Photo) ? bytesFromBase64(object.Photo) : new Uint8Array(0),
      AccountID: isSet(object.AccountID) ? globalThis.String(object.AccountID) : "",
    };
  },

  toJSON(message: Student): unknown {
    const obj: any = {};
    if (message.FirstName !== "") {
      obj.FirstName = message.FirstName;
    }
    if (message.MiddleName !== "") {
      obj.MiddleName = message.MiddleName;
    }
    if (message.LastName !== "") {
      obj.LastName = message.LastName;
    }
    if (message.BornDate !== "") {
      obj.BornDate = message.BornDate;
    }
    if (message.Education !== "") {
      obj.Education = message.Education;
    }
    if (message.Location !== "") {
      obj.Location = message.Location;
    }
    if (message.PhotoURL !== "") {
      obj.PhotoURL = message.PhotoURL;
    }
    if (message.Photo.length !== 0) {
      obj.Photo = base64FromBytes(message.Photo);
    }
    if (message.AccountID !== "") {
      obj.AccountID = message.AccountID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Student>, I>>(base?: I): Student {
    return Student.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Student>, I>>(object: I): Student {
    const message = createBaseStudent();
    message.FirstName = object.FirstName ?? "";
    message.MiddleName = object.MiddleName ?? "";
    message.LastName = object.LastName ?? "";
    message.BornDate = object.BornDate ?? "";
    message.Education = object.Education ?? "";
    message.Location = object.Location ?? "";
    message.PhotoURL = object.PhotoURL ?? "";
    message.Photo = object.Photo ?? new Uint8Array(0);
    message.AccountID = object.AccountID ?? "";
    return message;
  },
};

function createBaseStudentCreateRequest(): StudentCreateRequest {
  return { student: undefined };
}

export const StudentCreateRequest: MessageFns<StudentCreateRequest> = {
  encode(message: StudentCreateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentCreateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentCreateRequest {
    return { student: isSet(object.student) ? Student.fromJSON(object.student) : undefined };
  },

  toJSON(message: StudentCreateRequest): unknown {
    const obj: any = {};
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentCreateRequest>, I>>(base?: I): StudentCreateRequest {
    return StudentCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentCreateRequest>, I>>(object: I): StudentCreateRequest {
    const message = createBaseStudentCreateRequest();
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    return message;
  },
};

function createBaseStudentCreateUpdateResponse(): StudentCreateUpdateResponse {
  return { id: "", message: "", student: undefined };
}

export const StudentCreateUpdateResponse: MessageFns<StudentCreateUpdateResponse> = {
  encode(message: StudentCreateUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentCreateUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentCreateUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentCreateUpdateResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      student: isSet(object.student) ? Student.fromJSON(object.student) : undefined,
    };
  },

  toJSON(message: StudentCreateUpdateResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentCreateUpdateResponse>, I>>(base?: I): StudentCreateUpdateResponse {
    return StudentCreateUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentCreateUpdateResponse>, I>>(object: I): StudentCreateUpdateResponse {
    const message = createBaseStudentCreateUpdateResponse();
    message.id = object.id ?? "";
    message.message = object.message ?? "";
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    return message;
  },
};

function createBaseStudentUpdateRequest(): StudentUpdateRequest {
  return { studentId: "", student: undefined };
}

export const StudentUpdateRequest: MessageFns<StudentUpdateRequest> = {
  encode(message: StudentUpdateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.studentId !== "") {
      writer.uint32(10).string(message.studentId);
    }
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentUpdateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.studentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentUpdateRequest {
    return {
      studentId: isSet(object.studentId) ? globalThis.String(object.studentId) : "",
      student: isSet(object.student) ? Student.fromJSON(object.student) : undefined,
    };
  },

  toJSON(message: StudentUpdateRequest): unknown {
    const obj: any = {};
    if (message.studentId !== "") {
      obj.studentId = message.studentId;
    }
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentUpdateRequest>, I>>(base?: I): StudentUpdateRequest {
    return StudentUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentUpdateRequest>, I>>(object: I): StudentUpdateRequest {
    const message = createBaseStudentUpdateRequest();
    message.studentId = object.studentId ?? "";
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    return message;
  },
};

function createBaseGetStudentByIDRequest(): GetStudentByIDRequest {
  return { studentId: "" };
}

export const GetStudentByIDRequest: MessageFns<GetStudentByIDRequest> = {
  encode(message: GetStudentByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.studentId !== "") {
      writer.uint32(10).string(message.studentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.studentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentByIDRequest {
    return { studentId: isSet(object.studentId) ? globalThis.String(object.studentId) : "" };
  },

  toJSON(message: GetStudentByIDRequest): unknown {
    const obj: any = {};
    if (message.studentId !== "") {
      obj.studentId = message.studentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentByIDRequest>, I>>(base?: I): GetStudentByIDRequest {
    return GetStudentByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentByIDRequest>, I>>(object: I): GetStudentByIDRequest {
    const message = createBaseGetStudentByIDRequest();
    message.studentId = object.studentId ?? "";
    return message;
  },
};

function createBaseGetStudentByIDResponse(): GetStudentByIDResponse {
  return { student: undefined };
}

export const GetStudentByIDResponse: MessageFns<GetStudentByIDResponse> = {
  encode(message: GetStudentByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentByIDResponse {
    return { student: isSet(object.student) ? Student.fromJSON(object.student) : undefined };
  },

  toJSON(message: GetStudentByIDResponse): unknown {
    const obj: any = {};
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentByIDResponse>, I>>(base?: I): GetStudentByIDResponse {
    return GetStudentByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentByIDResponse>, I>>(object: I): GetStudentByIDResponse {
    const message = createBaseGetStudentByIDResponse();
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    return message;
  },
};

function createBaseListStudentsRequest(): ListStudentsRequest {
  return {};
}

export const ListStudentsRequest: MessageFns<ListStudentsRequest> = {
  encode(_: ListStudentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStudentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListStudentsRequest {
    return {};
  },

  toJSON(_: ListStudentsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudentsRequest>, I>>(base?: I): ListStudentsRequest {
    return ListStudentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudentsRequest>, I>>(_: I): ListStudentsRequest {
    const message = createBaseListStudentsRequest();
    return message;
  },
};

function createBaseListStudentsResponse(): ListStudentsResponse {
  return { students: [] };
}

export const ListStudentsResponse: MessageFns<ListStudentsResponse> = {
  encode(message: ListStudentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.students) {
      Student.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStudentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.students.push(Student.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStudentsResponse {
    return {
      students: globalThis.Array.isArray(object?.students) ? object.students.map((e: any) => Student.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListStudentsResponse): unknown {
    const obj: any = {};
    if (message.students?.length) {
      obj.students = message.students.map((e) => Student.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudentsResponse>, I>>(base?: I): ListStudentsResponse {
    return ListStudentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudentsResponse>, I>>(object: I): ListStudentsResponse {
    const message = createBaseListStudentsResponse();
    message.students = object.students?.map((e) => Student.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenExistsRequest(): TokenExistsRequest {
  return { subjectId: "" };
}

export const TokenExistsRequest: MessageFns<TokenExistsRequest> = {
  encode(message: TokenExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectId !== "") {
      writer.uint32(10).string(message.subjectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenExistsRequest {
    return { subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "" };
  },

  toJSON(message: TokenExistsRequest): unknown {
    const obj: any = {};
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenExistsRequest>, I>>(base?: I): TokenExistsRequest {
    return TokenExistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenExistsRequest>, I>>(object: I): TokenExistsRequest {
    const message = createBaseTokenExistsRequest();
    message.subjectId = object.subjectId ?? "";
    return message;
  },
};

function createBaseTokenExistsResponse(): TokenExistsResponse {
  return { exists: false };
}

export const TokenExistsResponse: MessageFns<TokenExistsResponse> = {
  encode(message: TokenExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenExistsResponse {
    return { exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false };
  },

  toJSON(message: TokenExistsResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenExistsResponse>, I>>(base?: I): TokenExistsResponse {
    return TokenExistsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenExistsResponse>, I>>(object: I): TokenExistsResponse {
    const message = createBaseTokenExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  },
};

function createBaseGetStudentByTokenRequest(): GetStudentByTokenRequest {
  return {};
}

export const GetStudentByTokenRequest: MessageFns<GetStudentByTokenRequest> = {
  encode(_: GetStudentByTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentByTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStudentByTokenRequest {
    return {};
  },

  toJSON(_: GetStudentByTokenRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentByTokenRequest>, I>>(base?: I): GetStudentByTokenRequest {
    return GetStudentByTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentByTokenRequest>, I>>(_: I): GetStudentByTokenRequest {
    const message = createBaseGetStudentByTokenRequest();
    return message;
  },
};

export interface StudentService {
  CreateStudent(request: StudentCreateRequest): Promise<StudentCreateUpdateResponse>;
  UpdateStudent(request: StudentUpdateRequest): Promise<StudentCreateUpdateResponse>;
  GetStudentByID(request: GetStudentByIDRequest): Promise<GetStudentByIDResponse>;
  GetStudentByToken(request: GetStudentByTokenRequest): Promise<StudentCreateUpdateResponse>;
  ListStudents(request: ListStudentsRequest): Promise<ListStudentsResponse>;
  TokenExists(request: TokenExistsRequest): Promise<TokenExistsResponse>;
}

export const StudentServiceServiceName = "student.StudentService";
export class StudentServiceClientImpl implements StudentService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || StudentServiceServiceName;
    this.rpc = rpc;
    this.CreateStudent = this.CreateStudent.bind(this);
    this.UpdateStudent = this.UpdateStudent.bind(this);
    this.GetStudentByID = this.GetStudentByID.bind(this);
    this.GetStudentByToken = this.GetStudentByToken.bind(this);
    this.ListStudents = this.ListStudents.bind(this);
    this.TokenExists = this.TokenExists.bind(this);
  }
  CreateStudent(request: StudentCreateRequest): Promise<StudentCreateUpdateResponse> {
    const data = StudentCreateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateStudent", data);
    return promise.then((data) => StudentCreateUpdateResponse.decode(new BinaryReader(data)));
  }

  UpdateStudent(request: StudentUpdateRequest): Promise<StudentCreateUpdateResponse> {
    const data = StudentUpdateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateStudent", data);
    return promise.then((data) => StudentCreateUpdateResponse.decode(new BinaryReader(data)));
  }

  GetStudentByID(request: GetStudentByIDRequest): Promise<GetStudentByIDResponse> {
    const data = GetStudentByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStudentByID", data);
    return promise.then((data) => GetStudentByIDResponse.decode(new BinaryReader(data)));
  }

  GetStudentByToken(request: GetStudentByTokenRequest): Promise<StudentCreateUpdateResponse> {
    const data = GetStudentByTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStudentByToken", data);
    return promise.then((data) => StudentCreateUpdateResponse.decode(new BinaryReader(data)));
  }

  ListStudents(request: ListStudentsRequest): Promise<ListStudentsResponse> {
    const data = ListStudentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListStudents", data);
    return promise.then((data) => ListStudentsResponse.decode(new BinaryReader(data)));
  }

  TokenExists(request: TokenExistsRequest): Promise<TokenExistsResponse> {
    const data = TokenExistsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TokenExists", data);
    return promise.then((data) => TokenExistsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
