// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.3
// source: cloudevent.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Any } from "./google/protobuf/any";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "io.cloudevents.v1";

/**
 * CloudEvent is copied from
 * https://github.com/cloudevents/spec/blob/main/cloudevents/formats/protobuf-format.md.
 */
export interface CloudEvent {
    /** Unique event identifier. */
    id: string;
    /** URI of the event source. */
    source: string;
    /** Version of the spec in use. */
    specVersion: string;
    /** Event type identifier. */
    type: string;
    /** Optional & Extension Attributes */
    attributes: { [key: string]: CloudEventAttributeValue };
    /**
     * If the event is binary data then the datacontenttype attribute
     * should be set to an appropriate media-type.
     */
    binaryData?: Uint8Array | undefined;
    /**
     * If the event is string data then the datacontenttype attribute
     * should be set to an appropriate media-type such as application/json.
     */
    textData?: string | undefined;
    /**
     * If the event is a protobuf then it must be encoded using this Any
     * type. The datacontenttype attribute should be set to
     * application/protobuf and the dataschema attribute set to the message
     * type.
     */
    protoData?: Any | undefined;
}

export interface CloudEvent_AttributesEntry {
    key: string;
    value: CloudEventAttributeValue | undefined;
}

/**
 * CloudEventAttribute enables extensions to use any of the seven allowed
 * data types as the value of an envelope key.
 */
export interface CloudEventAttributeValue {
    /** Boolean value. */
    ceBoolean?: boolean | undefined;
    /** Integer value. */
    ceInteger?: number | undefined;
    /** String value. */
    ceString?: string | undefined;
    /** Byte string value. */
    ceBytes?: Uint8Array | undefined;
    /** URI value. */
    ceUri?: string | undefined;
    /** URI reference value. */
    ceUriRef?: string | undefined;
    /** Timestamp value. */
    ceTimestamp?: Date | undefined;
}

export interface PublishRequest {
    /** Required. Define the CloudEvent to be published */
    event: CloudEvent | undefined;
}

export interface SubscriptionRequest {
    /** Required. The original source of the respond CloudEvent(s). */
    source: string;
}

function createBaseCloudEvent(): CloudEvent {
    return {
        id: "",
        source: "",
        specVersion: "",
        type: "",
        attributes: {},
        binaryData: undefined,
        textData: undefined,
        protoData: undefined,
    };
}

export const CloudEvent = {
    encode(
        message: CloudEvent,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.source !== "") {
            writer.uint32(18).string(message.source);
        }
        if (message.specVersion !== "") {
            writer.uint32(26).string(message.specVersion);
        }
        if (message.type !== "") {
            writer.uint32(34).string(message.type);
        }
        Object.entries(message.attributes).forEach(([key, value]) => {
            CloudEvent_AttributesEntry.encode(
                { key: key as any, value },
                writer.uint32(42).fork()
            ).ldelim();
        });
        if (message.binaryData !== undefined) {
            writer.uint32(50).bytes(message.binaryData);
        }
        if (message.textData !== undefined) {
            writer.uint32(58).string(message.textData);
        }
        if (message.protoData !== undefined) {
            Any.encode(message.protoData, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): CloudEvent {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCloudEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.source = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }

                    message.specVersion = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }

                    message.type = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }

                    const entry5 = CloudEvent_AttributesEntry.decode(
                        reader,
                        reader.uint32()
                    );
                    if (entry5.value !== undefined) {
                        message.attributes[entry5.key] = entry5.value;
                    }
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }

                    message.binaryData = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }

                    message.textData = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }

                    message.protoData = Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): CloudEvent {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            source: isSet(object.source)
                ? globalThis.String(object.source)
                : "",
            specVersion: isSet(object.specVersion)
                ? globalThis.String(object.specVersion)
                : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            attributes: isObject(object.attributes)
                ? Object.entries(object.attributes).reduce<{
                      [key: string]: CloudEventAttributeValue;
                  }>((acc, [key, value]) => {
                      acc[key] = CloudEventAttributeValue.fromJSON(value);
                      return acc;
                  }, {})
                : {},
            binaryData: isSet(object.binaryData)
                ? bytesFromBase64(object.binaryData)
                : undefined,
            textData: isSet(object.textData)
                ? globalThis.String(object.textData)
                : undefined,
            protoData: isSet(object.protoData)
                ? Any.fromJSON(object.protoData)
                : undefined,
        };
    },

    toJSON(message: CloudEvent): unknown {
        const obj: any = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.source !== "") {
            obj.source = message.source;
        }
        if (message.specVersion !== "") {
            obj.specVersion = message.specVersion;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.attributes) {
            const entries = Object.entries(message.attributes);
            if (entries.length > 0) {
                obj.attributes = {};
                entries.forEach(([k, v]) => {
                    obj.attributes[k] = CloudEventAttributeValue.toJSON(v);
                });
            }
        }
        if (message.binaryData !== undefined) {
            obj.binaryData = base64FromBytes(message.binaryData);
        }
        if (message.textData !== undefined) {
            obj.textData = message.textData;
        }
        if (message.protoData !== undefined) {
            obj.protoData = Any.toJSON(message.protoData);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<CloudEvent>, I>>(base?: I): CloudEvent {
        return CloudEvent.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CloudEvent>, I>>(
        object: I
    ): CloudEvent {
        const message = createBaseCloudEvent();
        message.id = object.id ?? "";
        message.source = object.source ?? "";
        message.specVersion = object.specVersion ?? "";
        message.type = object.type ?? "";
        message.attributes = Object.entries(object.attributes ?? {}).reduce<{
            [key: string]: CloudEventAttributeValue;
        }>((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = CloudEventAttributeValue.fromPartial(value);
            }
            return acc;
        }, {});
        message.binaryData = object.binaryData ?? undefined;
        message.textData = object.textData ?? undefined;
        message.protoData =
            object.protoData !== undefined && object.protoData !== null
                ? Any.fromPartial(object.protoData)
                : undefined;
        return message;
    },
};

function createBaseCloudEvent_AttributesEntry(): CloudEvent_AttributesEntry {
    return { key: "", value: undefined };
}

export const CloudEvent_AttributesEntry = {
    encode(
        message: CloudEvent_AttributesEntry,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            CloudEventAttributeValue.encode(
                message.value,
                writer.uint32(18).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): CloudEvent_AttributesEntry {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCloudEvent_AttributesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.value = CloudEventAttributeValue.decode(
                        reader,
                        reader.uint32()
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): CloudEvent_AttributesEntry {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value)
                ? CloudEventAttributeValue.fromJSON(object.value)
                : undefined,
        };
    },

    toJSON(message: CloudEvent_AttributesEntry): unknown {
        const obj: any = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = CloudEventAttributeValue.toJSON(message.value);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<CloudEvent_AttributesEntry>, I>>(
        base?: I
    ): CloudEvent_AttributesEntry {
        return CloudEvent_AttributesEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CloudEvent_AttributesEntry>, I>>(
        object: I
    ): CloudEvent_AttributesEntry {
        const message = createBaseCloudEvent_AttributesEntry();
        message.key = object.key ?? "";
        message.value =
            object.value !== undefined && object.value !== null
                ? CloudEventAttributeValue.fromPartial(object.value)
                : undefined;
        return message;
    },
};

function createBaseCloudEventAttributeValue(): CloudEventAttributeValue {
    return {
        ceBoolean: undefined,
        ceInteger: undefined,
        ceString: undefined,
        ceBytes: undefined,
        ceUri: undefined,
        ceUriRef: undefined,
        ceTimestamp: undefined,
    };
}

export const CloudEventAttributeValue = {
    encode(
        message: CloudEventAttributeValue,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.ceBoolean !== undefined) {
            writer.uint32(8).bool(message.ceBoolean);
        }
        if (message.ceInteger !== undefined) {
            writer.uint32(16).int32(message.ceInteger);
        }
        if (message.ceString !== undefined) {
            writer.uint32(26).string(message.ceString);
        }
        if (message.ceBytes !== undefined) {
            writer.uint32(34).bytes(message.ceBytes);
        }
        if (message.ceUri !== undefined) {
            writer.uint32(42).string(message.ceUri);
        }
        if (message.ceUriRef !== undefined) {
            writer.uint32(50).string(message.ceUriRef);
        }
        if (message.ceTimestamp !== undefined) {
            Timestamp.encode(
                toTimestamp(message.ceTimestamp),
                writer.uint32(58).fork()
            ).ldelim();
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): CloudEventAttributeValue {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCloudEventAttributeValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }

                    message.ceBoolean = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }

                    message.ceInteger = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }

                    message.ceString = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }

                    message.ceBytes = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }

                    message.ceUri = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }

                    message.ceUriRef = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }

                    message.ceTimestamp = fromTimestamp(
                        Timestamp.decode(reader, reader.uint32())
                    );
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): CloudEventAttributeValue {
        return {
            ceBoolean: isSet(object.ceBoolean)
                ? globalThis.Boolean(object.ceBoolean)
                : undefined,
            ceInteger: isSet(object.ceInteger)
                ? globalThis.Number(object.ceInteger)
                : undefined,
            ceString: isSet(object.ceString)
                ? globalThis.String(object.ceString)
                : undefined,
            ceBytes: isSet(object.ceBytes)
                ? bytesFromBase64(object.ceBytes)
                : undefined,
            ceUri: isSet(object.ceUri)
                ? globalThis.String(object.ceUri)
                : undefined,
            ceUriRef: isSet(object.ceUriRef)
                ? globalThis.String(object.ceUriRef)
                : undefined,
            ceTimestamp: isSet(object.ceTimestamp)
                ? fromJsonTimestamp(object.ceTimestamp)
                : undefined,
        };
    },

    toJSON(message: CloudEventAttributeValue): unknown {
        const obj: any = {};
        if (message.ceBoolean !== undefined) {
            obj.ceBoolean = message.ceBoolean;
        }
        if (message.ceInteger !== undefined) {
            obj.ceInteger = Math.round(message.ceInteger);
        }
        if (message.ceString !== undefined) {
            obj.ceString = message.ceString;
        }
        if (message.ceBytes !== undefined) {
            obj.ceBytes = base64FromBytes(message.ceBytes);
        }
        if (message.ceUri !== undefined) {
            obj.ceUri = message.ceUri;
        }
        if (message.ceUriRef !== undefined) {
            obj.ceUriRef = message.ceUriRef;
        }
        if (message.ceTimestamp !== undefined) {
            obj.ceTimestamp = message.ceTimestamp.toISOString();
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<CloudEventAttributeValue>, I>>(
        base?: I
    ): CloudEventAttributeValue {
        return CloudEventAttributeValue.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CloudEventAttributeValue>, I>>(
        object: I
    ): CloudEventAttributeValue {
        const message = createBaseCloudEventAttributeValue();
        message.ceBoolean = object.ceBoolean ?? undefined;
        message.ceInteger = object.ceInteger ?? undefined;
        message.ceString = object.ceString ?? undefined;
        message.ceBytes = object.ceBytes ?? undefined;
        message.ceUri = object.ceUri ?? undefined;
        message.ceUriRef = object.ceUriRef ?? undefined;
        message.ceTimestamp = object.ceTimestamp ?? undefined;
        return message;
    },
};

function createBasePublishRequest(): PublishRequest {
    return { event: undefined };
}

export const PublishRequest = {
    encode(
        message: PublishRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.event !== undefined) {
            CloudEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): PublishRequest {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublishRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.event = CloudEvent.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): PublishRequest {
        return {
            event: isSet(object.event)
                ? CloudEvent.fromJSON(object.event)
                : undefined,
        };
    },

    toJSON(message: PublishRequest): unknown {
        const obj: any = {};
        if (message.event !== undefined) {
            obj.event = CloudEvent.toJSON(message.event);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<PublishRequest>, I>>(
        base?: I
    ): PublishRequest {
        return PublishRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<PublishRequest>, I>>(
        object: I
    ): PublishRequest {
        const message = createBasePublishRequest();
        message.event =
            object.event !== undefined && object.event !== null
                ? CloudEvent.fromPartial(object.event)
                : undefined;
        return message;
    },
};

function createBaseSubscriptionRequest(): SubscriptionRequest {
    return { source: "" };
}

export const SubscriptionRequest = {
    encode(
        message: SubscriptionRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.source !== "") {
            writer.uint32(10).string(message.source);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): SubscriptionRequest {
        const reader =
            input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.source = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): SubscriptionRequest {
        return {
            source: isSet(object.source)
                ? globalThis.String(object.source)
                : "",
        };
    },

    toJSON(message: SubscriptionRequest): unknown {
        const obj: any = {};
        if (message.source !== "") {
            obj.source = message.source;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<SubscriptionRequest>, I>>(
        base?: I
    ): SubscriptionRequest {
        return SubscriptionRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SubscriptionRequest>, I>>(
        object: I
    ): SubscriptionRequest {
        const message = createBaseSubscriptionRequest();
        message.source = object.source ?? "";
        return message;
    },
};

export interface CloudEventService {
    Publish(request: PublishRequest): Promise<Empty>;
    Subscribe(request: SubscriptionRequest): Observable<CloudEvent>;
}

export const CloudEventServiceServiceName =
    "io.cloudevents.v1.CloudEventService";
export class CloudEventServiceClientImpl implements CloudEventService {
    private readonly rpc: Rpc;
    private readonly service: string;
    constructor(rpc: Rpc, opts?: { service?: string }) {
        this.service = opts?.service || CloudEventServiceServiceName;
        this.rpc = rpc;
        this.Publish = this.Publish.bind(this);
        this.Subscribe = this.Subscribe.bind(this);
    }
    Publish(request: PublishRequest): Promise<Empty> {
        const data = PublishRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Publish", data);
        return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
    }

    Subscribe(request: SubscriptionRequest): Observable<CloudEvent> {
        const data = SubscriptionRequest.encode(request).finish();
        const result = this.rpc.serverStreamingRequest(
            this.service,
            "Subscribe",
            data
        );
        return result.pipe(
            map((data) => CloudEvent.decode(_m0.Reader.create(data)))
        );
    }
}

interface Rpc {
    request(
        service: string,
        method: string,
        data: Uint8Array
    ): Promise<Uint8Array>;
    clientStreamingRequest(
        service: string,
        method: string,
        data: Observable<Uint8Array>
    ): Promise<Uint8Array>;
    serverStreamingRequest(
        service: string,
        method: string,
        data: Uint8Array
    ): Observable<Uint8Array>;
    bidirectionalStreamingRequest(
        service: string,
        method: string,
        data: Observable<Uint8Array>
    ): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
    if ((globalThis as any).Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}

function base64FromBytes(arr: Uint8Array): string {
    if ((globalThis as any).Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin: string[] = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}

type Builtin =
    | Date
    | Function
    | Uint8Array
    | string
    | number
    | boolean
    | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
          [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
      };

function toTimestamp(date: Date): Timestamp {
    const seconds = Math.trunc(date.getTime() / 1_000);
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
    if (o instanceof globalThis.Date) {
        return o;
    } else if (typeof o === "string") {
        return new globalThis.Date(o);
    } else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}

function isObject(value: any): boolean {
    return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}
